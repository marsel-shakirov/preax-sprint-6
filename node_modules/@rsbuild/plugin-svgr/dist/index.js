import * as __WEBPACK_EXTERNAL_MODULE_node_path_c5b9b54f__ from "node:path";
import * as __WEBPACK_EXTERNAL_MODULE_node_url_e96de089__ from "node:url";
import * as __WEBPACK_EXTERNAL_MODULE__rsbuild_plugin_react_7b149ee4__ from "@rsbuild/plugin-react";
import * as __WEBPACK_EXTERNAL_MODULE_deepmerge__ from "deepmerge";
let src_dirname = __WEBPACK_EXTERNAL_MODULE_node_path_c5b9b54f__.default.dirname((0, __WEBPACK_EXTERNAL_MODULE_node_url_e96de089__.fileURLToPath)(import.meta.url)), SVG_REGEX = /\.svg$/, getSvgoDefaultConfig = ()=>({
        plugins: [
            {
                name: 'preset-default',
                params: {
                    overrides: {
                        removeViewBox: !1
                    }
                }
            },
            'prefixIds'
        ]
    }), dedupeSvgoPlugins = (config)=>{
    if (!config.plugins) return config;
    let mergedPlugins = [];
    for (let plugin of config.plugins){
        if ('string' == typeof plugin) {
            mergedPlugins.find((item)=>item === plugin || 'object' == typeof item && item.name === plugin) || mergedPlugins.push(plugin);
            continue;
        }
        let strIndex = mergedPlugins.findIndex((item)=>'string' == typeof item && item === plugin.name);
        if (-1 !== strIndex) {
            mergedPlugins[strIndex] = plugin;
            continue;
        }
        let isMerged = !1;
        mergedPlugins = mergedPlugins.map((item)=>'object' == typeof item && item.name === plugin.name ? (isMerged = !0, (0, __WEBPACK_EXTERNAL_MODULE_deepmerge__.default)(item, plugin)) : item), isMerged || mergedPlugins.push(plugin);
    }
    return config.plugins = mergedPlugins, config;
}, PLUGIN_SVGR_NAME = 'rsbuild:svgr', pluginSvgr = (options = {})=>({
        name: PLUGIN_SVGR_NAME,
        pre: [
            __WEBPACK_EXTERNAL_MODULE__rsbuild_plugin_react_7b149ee4__.PLUGIN_REACT_NAME
        ],
        setup (api) {
            api.modifyBundlerChain(async (chain, { CHAIN_ID, environment })=>{
                let { config } = environment, { dataUriLimit } = config.output, maxSize = 'number' == typeof dataUriLimit ? dataUriLimit : dataUriLimit.svg, generatorOptions = {};
                chain.module.rules.has(CHAIN_ID.RULE.SVG) && (generatorOptions = chain.module.rules.get(CHAIN_ID.RULE.SVG).oneOfs.get(CHAIN_ID.ONE_OF.SVG_URL).get('generator'), chain.module.rules.delete(CHAIN_ID.RULE.SVG));
                let rule = chain.module.rule(CHAIN_ID.RULE.SVG).test(SVG_REGEX), svgrOptions = (0, __WEBPACK_EXTERNAL_MODULE_deepmerge__.default)({
                    svgo: !0,
                    svgoConfig: getSvgoDefaultConfig()
                }, options.svgrOptions || {});
                svgrOptions.svgoConfig = dedupeSvgoPlugins(svgrOptions.svgoConfig), rule.oneOf(CHAIN_ID.ONE_OF.SVG_URL).type('asset/resource').resourceQuery(/(__inline=false|url)/).set('generator', generatorOptions), rule.oneOf(CHAIN_ID.ONE_OF.SVG_INLINE).type('asset/inline').resourceQuery(/inline/), CHAIN_ID.ONE_OF.SVG_RAW && rule.oneOf(CHAIN_ID.ONE_OF.SVG_RAW).type('asset/source').resourceQuery(/raw/), rule.oneOf(CHAIN_ID.ONE_OF.SVG_REACT).type("javascript/auto").resourceQuery(options.query || /react/).use(CHAIN_ID.USE.SVGR).loader(__WEBPACK_EXTERNAL_MODULE_node_path_c5b9b54f__.default.resolve(src_dirname, './loader.mjs')).options({
                    ...svgrOptions,
                    exportType: 'default'
                }).end();
                let { mixedImport = !1 } = options;
                if (mixedImport || svgrOptions.exportType) {
                    let { exportType = mixedImport ? 'named' : void 0 } = svgrOptions, issuerInclude = [
                        /\.(?:js|jsx|mjs|cjs|ts|tsx|mts|cts)$/,
                        /\.mdx$/
                    ], issuer = options.excludeImporter ? {
                        and: [
                            issuerInclude,
                            {
                                not: options.excludeImporter
                            }
                        ]
                    } : issuerInclude, svgRule = rule.oneOf(CHAIN_ID.ONE_OF.SVG);
                    options.exclude && svgRule.exclude.add(options.exclude), svgRule.type("javascript/auto").set('issuer', issuer).use(CHAIN_ID.USE.SVGR).loader(__WEBPACK_EXTERNAL_MODULE_node_path_c5b9b54f__.default.resolve(src_dirname, './loader.mjs')).options({
                        ...svgrOptions,
                        exportType
                    }).end(), mixedImport && 'named' === exportType && svgRule.use(CHAIN_ID.USE.URL).loader(__WEBPACK_EXTERNAL_MODULE_node_path_c5b9b54f__.default.join(src_dirname, '../compiled', 'url-loader/index.js')).options({
                        limit: maxSize,
                        name: null == generatorOptions ? void 0 : generatorOptions.filename
                    });
                }
                rule.oneOf(CHAIN_ID.ONE_OF.SVG_ASSET).type('asset').parser({
                    dataUrlCondition: {
                        maxSize
                    }
                }).set('generator', generatorOptions);
                let jsRule = chain.module.rules.get(CHAIN_ID.RULE.JS);
                [
                    CHAIN_ID.USE.SWC,
                    CHAIN_ID.USE.BABEL
                ].some((jsUseId)=>{
                    let use = jsRule.uses.get(jsUseId);
                    if (!use) return !1;
                    for (let oneOfId of [
                        CHAIN_ID.ONE_OF.SVG,
                        CHAIN_ID.ONE_OF.SVG_REACT
                    ])rule.oneOfs.has(oneOfId) && rule.oneOf(oneOfId).use(jsUseId).before(CHAIN_ID.USE.SVGR).loader(use.get('loader')).options(use.get('options'));
                    return !0;
                });
            });
        }
    });
export { PLUGIN_SVGR_NAME, pluginSvgr };
